# Usage
Detailed overview of the currently supported methods and data models used to communicate with your ThingsBoard server.

## Initialization and Login (Authentication)
A client object can be initialized in two different ways - and requires to provide login data. Either by username/password or access tokens retrieved by a previous session. The following initializers are implemented as failable and will do so, if their parameters are provided with an empty string.
* ``TBUserApiClient/init(baseUrlStr:username:password:logger:)``: server url, authentication by username and password 
* ``TBUserApiClient/init(baseUrlStr:accessToken:logger:)``: server url, authentication by access token retrieved from a previous session

Since Version 0.0.11 both initializers support an (optional) `logger` parameter which takes an `Logger?` instance (from *OSLog*) as argument.
```swift
import OSLog
import TBRESTClientLib

let logger = Logger(subsystem: "myApp.TBRESTClientLib", category: "Library")
let myClient = try? TBUserApiClient(baseUrlStr: "https://my-thingsboard-iot-server.com",
                                    username: "MyUsername",
                                    password: "MySuperSecretPassword",
                                    logger: logger)
```

A third option with a custom http session handler exists `init(baseUrlStr:username:password:httpSessionHandler:)` but is intentionally not marked as public because its main purpose is to be used with a mock http client for unit testing.

### Initialization with username/password

#### Applies to version >= 0.0.10
The following listing shows initialization by username and password. After initialization, make sure to register a specific error handler for your application. ``TBHTTPRequest/registerErrorHandler(apiErrorHandler:systemErrorHandler:)`` is always called when a request fails. Since **version 0.0.10** `TBHTTPRequest/registerAppErrorHandler(errorHandler:)` was replaced with ``TBHTTPRequest/registerErrorHandler(apiErrorHandler:systemErrorHandler:)`` which now distinguishes between errors generated by the API and errors thrown by the local system. 

The parameter `apiErrorHandler` is used to register a callback function that handles API-related errors. This function takes a single argument of type ``TBAppError`` and is triggered when the API returns an error, such as an invalid response or a server-side error (e.g. HTTP 500).

The parameter `systemErrorHandler` is used to register a callback function that handles system-level errors. It takes a single argument of type ``TBHTTPClientRequestError`` and is invoked when local issues occur, such as a failed hostname resolution or an unreachable server.

```swift
import TBRESTClientLib
let myClient = try? TBUserApiClient(baseUrlStr: "https://my-thingsboard-iot-server-which-is-currently-unavailable.com", username: "MyUsername", password: "MySuperSecretPassword")

myClient?.registerErrorHandler(
    apiErrorHandler: { apiError in
        print("API Error: \(apiError)")
    },
    systemErrorHandler: { systemError in
        print("System Error: \(systemError)")
})
```
Both parameters are optional, meaning they can be set or updated individually at any time. This provides greater flexibility in implementing the desired error handling strategy in the app using this library.

#### Applies to version <= 0.0.9
The following listing shows initialization by username and password. After initialization, make sure to register a specific error handler for your application. `TBHTTPRequest/registerAppErrorHandler(errorHandler:)` is always called when a request to the server fails. The cause of failure doesn't matter (e.g. server not reachable, incorrect authentication or incorrect server request).
```swift
import TBRESTClientLib
let myClient = try? TBUserApiClient(baseUrlStr: "https://my-thingsboard-iot-server.com", username: "MyUsername", password: "MySuperSecretPassword")

myClient?.registerAppErrorHandler { errorMsg in
    print("Unexpected error: \(errorMsg)")
}
```
Types involved: ``TBAppError``

### Login when initialized with username/password
When a client is initialized with username/password the ``TBUserApiClient/login(responseHandler:)`` method can be called afterwards. This generates a login token which remains with the client until it is deinitalized or cleand up.
```swift
try? myClient?.login() { authToken in
    print("\(authToken)")
}
```
Types involved: ``AuthLogin``

### Initialization with existing access token
Initialization can also be performed by using a previosuly feteched access token (instead of username/password). The procedure mainly stays the same as described above: init client, then register error handler
```swift
let accessToken = AuthLogin(token: "MyAccessToken", refreshToken: "MyRefreshToken")
let myClient2 = try? TBUserApiClient(baseUrlStr: "https://my-thingsboard-iot-server.com", accessToken: accessToken)

// version <= 0.0.9
myClient2?.registerAppErrorHandler() { errorMsg in
    print("Unexpected error: \(errorMsg)")
}

// version >= 0.0.10
myClient2?.registerErrorHandler(
    apiErrorHandler: { apiError in
        print("API Error: \(apiError)")
    },
    systemErrorHandler: { systemError in
        print("System Error: \(systemError)")
})
```
Types involved: ``AuthLogin``, ``TBAppError``

### Login when initialized with access token
When initialized with an access token it may be the case to *renew* the login (e.g. because the server rejects an invalidated access token). In this case ``TBUserApiClient/login(withUsername:andPassword:responseHandler:)`` needs to be called to obtain a new access token.
```swift
try? myClient2?.login(withUsername: "MyUsername", andPassword: "MySuperSecretPassword"){ authToken in
    print("\(authToken)")
}
```
Types involved: ``AuthLogin``

### Access Login Data
Use ``TBUserApiClient/getLoginData()`` when working with multiple ``TBUserApiClient`` instances to retrieve the login data provided during initialization. The returned data includes the server URL and username. For security reasons, the password is not returned.
```swift
let loginData = myClient?.getLoginData()
let serverUrl = loginData.0
let username = loginData.1
```

``TBUserApiClient/getAccessToken()`` retrieves the access token that is currently in use. The token can be reused to restore an existing authentication session, for example when recovering a client state without performing a new login. (Refer to <doc:Usage/Initialization-with-existing-access-token> for initializing the client with an access token.)
```swift
let accessToken = myClient?.getAccessToken()
```

### Logout
Request user logout on ThingsBoard server and destroy access token locally.
```swift
myClient?.logout()
```
Calling ``TBUserApiClient/logout()`` on the server side serves the purpose of audit logging, as the logout request is written to the audit log. The main logout procedure, however, takes place on the client side by clearing the access token.

## User Profile
To perform user-specific requests (e.g. user-accessible devices or profiles) it is mandatorry to include a user-id reference to these requests. Therefore it is required to obtain its own user-id first. More details about ``TBUserApiClient/getUser(responseHandler:)``
```swift
var userInfo: User?

self.myClient?.getUser() { userInfo in
    self.userInfo = userInfo
    print("\(self.userInfo)")
}
```
Types involved: ``User``

## Customer Info
To get information about the customer a user belongs to, use ``TBUserApiClient/getCustomerById(customerId:responseHandler:)``
```swift
let customerId: String = "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
var customerInfo: Customer?
apiClient?.getCustomerById(customerId: customerId) { customer in
    customerInfo = customer
    print("\(self.customerInfo)")
```
Types involved: ``Customer``


## Devices and device profiles
Working with devices and device profiles.

### Get devices and device infos
Get devices and device infos for the customer the user belongs to. Response supports pagination. This is automatically neglected when using default arguments for function parameters, assuming a response with decent number of devices. ``TBUserApiClient/getCustomerDeviceInfos(customerId:pageSize:page:type:deviceProfileId:active:textSearch:sortProperty:sortOrder:responseHandler:)`` gives more flexibility compared to ``TBUserApiClient/getCustomerDevices(customerId:pageSize:page:type:textSearch:sortProperty:sortOrder:responseHandler:)``. To minimize complexity, return type is the same for both functions.

#### getCustomerDeviceInfos()
```swift
var devices: [Device]! = []

// picking up all devices assuming there are not hundreds/thousands - therefore omitting the use of proper pagination
myClient?.getCustomerDeviceInfos(customerId: userInfo?.customerId.id ?? "") { tbDevicesPaginated in
    self.devices = tbDevicesPaginated.data
    print("\(self.devices)")
}
```
Types involved: ``PaginationDataContainer``, ``Device``

#### getCustomerDevices()
```swift
myClient?.getCustomerDevices(customerId: userInfo?.customerId.id ?? "") { customerDevices in
   print("\(customerDevices)")
}
```
Types involved: ``PaginationDataContainer``, ``Device``

### Get device profiles and device profile infos
Get device profiles and device profile infos. Response supports pagination. This is automatically neglected when using default arguments for function parameters, assuming a response with decent number of profiles. ``TBUserApiClient/getDeviceProfileInfos(pageSize:page:textSearch:sortProperty:sortOrder:transportType:responseHandler:)`` gives more flexibility compared to ``TBUserApiClient/getDeviceProfiles(pageSize:page:textSearch:sortProperty:sortOrder:responseHandler:)``. To minimize complexity, the return type is the same for both functions.

#### getDeviceProfileInfos()
```swift
myClient?.getDeviceProfileInfos() { deviceProfileInfos in
    print("\(deviceProfileInfos)")
}
```
Types involved: ``PaginationDataContainer``, ``DeviceProfile``

#### getDeviceProfiles()
```swift
myClient?.getDeviceProfiles() { deviceProfiles in
    print("\(deviceProfiles)")
}
```
Types involved: ``PaginationDataContainer``, ``DeviceProfile``


## Working with telemetry data
Telemetry data is grouped into *attributes* and *timeseries data*

### Entity attributes
Attributes are unique key-value pairs which are time-independant. Attributes can be set within a given scope ``TbQueryEntityScopes`` and for a given entity type ``TbQueryEntityScopes``.

#### getAttributeKeys()
Use ``TBUserApiClient/getAttributeKeys(for:entityId:responseHandler:)`` to get attribute keys for an entity type ``TbQueryEntityTypes``. This method does not support filtering by entity scope.
```swift
myClient?.getAttributeKeys(for: .device, entityId: "entityId-as-UUID-string") { attributesArray in
    print("\(attributesArray)")
}
```

#### getAttributeKeysByScope()
Use ``TBUserApiClient/getAttributeKeysByScope(for:entityId:scope:responseHandler:)`` to get **attribute keys** for an entity type ``TbQueryEntityTypes``, **filtered** by entity scope ``TbQueryEntityScopes``.
```swift
myClient?.getAttributeKeysByScope(for: .device, entityId: "entityId-as-UUID-string", scope: .server) { attributesArray in
    print("\(attributesArray)")
}
```

#### getAttributes()
``TBUserApiClient/getAttributes(for:entityId:keys:responseHandler:)`` retrieves complete attributes: key and its current value. 
```swift
myClient?.getAttributes(for: .device, entityId: tbDevice, keys: ["sampleAtt1String", "sampleAtt2Bool", "sampleAtt3Int", "sampleAtt4Double"]) { attributesArray in
    print("\(attributesArray)")
}
```
Types involved: ``AttributesResponse``

When accessing attributes, make sure to read the documentation for the type ``AttributesResponse``, its property ``AttributesResponse/value`` (and the properties type implementation ``MplValueType``).


#### getAttributesByScope()
``TBUserApiClient/getAttributesByScope(for:entityId:keys:scope:responseHandler:)`` retrieves complete attributes: key and its current value. This method requires to provide the desired attribute scope ``TbQueryEntityScopes``.
```swift
myClient?.getAttributesByScope(for: .device, entityId: "entityId-as-UUID-string", keys: ["sampleAtt1String", "sampleAtt2Bool", "sampleAtt3Int", "sampleAtt4Double"], scope: .shared) { attributesArray in
    print("\(attributesArray)")
}
```
Types involved: ``AttributesResponse``

When accessing attributes, make sure to read the documentation for the type ``AttributesResponse``, its property ``AttributesResponse/value`` (and the properties type implementation ``MplValueType``).

#### saveEntityAttributes()
Add new or modify existing attributes. Attributes can be defined as a `[String : Any]` dictionary. The response handler `() -> Void` is called when the operation completes successfully. Attributes are set for a given entity ``TbQueryEntityTypes`` and scope ``TbQueryEntityScopes``.
```swift
let sampleAttributes = ["sampleAtt1String":"Hello Server", "sampleAtt2Bool": true, "sampleAtt3Int": 4, "sampleAtt4Double": 3.1415926] as [String : Any]
myClient?.saveEntityAttributes(for: .device, entityId: "entityId-as-UUID-string", attributesData: sampleAttributes, scope: .shared) {
    print("Success!")
}
```

#### deleteEntityAttributes()
Existing attributes can be deleted by providing its keys inside an array. ``TBUserApiClient/deleteEntityAttributes(for:entityId:keys:scope:responseHandler:)`` takes a completion handler which is called on success. Attributes are deleted for a given entity ``TbQueryEntityTypes`` and scope ``TbQueryEntityScopes``.

```swift
let deleteAttributes = ["sampleAtt1String", "sampleAtt2Bool", "sampleAtt3Int", "sampleAtt4Double"]
myClient?.deleteEntityAttributes(for: .device, entityId: "entityId-as-UUID-string", keys: deleteAttributes, scope: .shared) {
    print("Success!")
}
```

### Entitiy timeseries data
Timeseries data work quite similar to attributes but are time-sensitive. It basically consists of a key-value pair but includes a timestamp. Available methods are quite similar to attributes methods. The timestamp is given as integer in milliseconds unix time (time since epoche 1970). In future versions, types containing *integer-timestamp-properties* might be extended to have another timestamp-property of the swift native type *Date*. 

#### getTimeseriesKeys()
Request timeseries data keys for given entity. ``TBUserApiClient/getTimeseriesKeys(for:entityId:responseHandler:)`` requires to provide entity by its UUID string and calls a completion handler on success. The completion handler takes the retrieved key names as argument (of type `Array<String>`). Keys are retrieved for a given entity ``TbQueryEntityTypes``.

```swift
myClient?.getTimeseriesKeys(for: .device, entityId: "entityId-as-UUID-string") { keyNames -> Void in
    print("\(keyNames)")
}
```

#### getLatestTimeseries()
Request latest timeseries data for given entity (``TbQueryEntityTypes``). Response contains last (youngest) timeseries data: a single key-value pair including timestamp. ``TBUserApiClient/getLatestTimeseries(for:entityId:keys:getValuesAsStrings:responseHandler:)`` has a parameter `getValuesAsStrings`. This tells the server to respond with all values as strings and not as native datatypes, such as int, bool, float. When a value contains a JSON string, it is highly recommended to set ` getValuesAsStrings: true` because parsing JSON strings inside response values is currently not supported by this library.

Timeseries data is retrieved for a given entity ``TbQueryEntityTypes``.

```swift
myClient?.getLatestTimeseries(for: .device, entityId: "entityId-as-UUID-string", keys: ["SampleIMEI", "SampleBattery"], getValuesAsStrings: false) { responseObject in
    if let sampleimei = responseObject["SampleIMEI"], let samplebattery = responseObject["SampleBattery"] {
        if getValuesAsStrings {
            // reflect values-as-string case
            if sampleimei?.value.stringVal == "999999999999999", samplebattery?.value.stringVal == "100" {
                print("Success!")
            } else {
                print("Expected different value/type!")
            }
        } else {
            // reflect values-as-native-types case
            if sampleimei?.value.intVal == 999999999999999, samplebattery?.value.intVal == 100 {
                print("Success!")
            } else {
                print("Expected different value/type!")
            }
        }
    } else {
        print("Expected key is missing in response!")
    }
}
```
Types involved: ``TimeseriesResponse``

To better understand ``TimeseriesResponse``'s value property, refer to ``TimeseriesResponse/value`` and ``MplValueType``. For further details about this endpoints parameters, please refer to the [API documentation](https://app.swaggerhub.com/apis-docs/johannes_kinzig/thingsboard-rest-api/3.7.0#/telemetry-controller/getLatestTimeseries).

#### getTimeseries()
Request timeseries data for given entity (``TbQueryEntityTypes``). Response contains timeseries data for given time frame: key-value pairs including timestamp. ``TBUserApiClient/getTimeseries(for:entityId:keys:startTs:endTs:intervalType:interval:timeZone:limit:aggregation:sortOrder:getValuesAsStrings:responseHandler:)`` has a parameter `getValuesAsStrings`. This tells the server to respond with all values as strings and not as native datatypes, such as int, bool, float. When a value contains a JSON string, it is highly recommended to set ` getValuesAsStrings: true` because parsing JSON strings inside response values is currently not supported by this library.

Timeseries data is retrieved for a given entity ``TbQueryEntityTypes``.

```swift
// request timeseries data for last seven days
let endTs = Int64(Date().timeIntervalSince1970) * 1000
let sevenDaysPast = Calendar.current.date(byAdding: .day, value: -7, to: Date())
let startTs = Int64(sevenDaysPast!.timeIntervalSince1970) * 1000

myClient?.getTimeseries(for: .device,
                        entityId: "entityId-as-UUID-string",
                        keys: ["SampleIMEI", "SampleBattery"],
                        startTs: startTs,
                        endTs: endTs,
                        limit: 10,
                        getValuesAsStrings: getValuesAsStrings) { responseObject in
    if let sampleimei = responseObject["SampleIMEI"], let samplebattery = responseObject["SampleBattery"] {
        if getValuesAsStrings {
            // reflect values-as-string case
            if sampleimei[0].value.stringVal == "999999999999999", samplebattery[0].value.stringVal == "100" {
                print("Success!")
            } else {
                print("Expected different value/type!")
            }
        } else {
            // reflect values-as-native-types case
            if sampleimei[0].value.intVal == 999999999999999, samplebattery[0].value.intVal == 100 {
                print("Success!")
            } else {
                print("Expected different value/type!")
            }
        }
    } else {
        print("Expected key missing in response!")
    }
}
```
Types involved: ``TimeseriesResponse``

To better understand ``TimeseriesResponse``'s value property, refer to ``TimeseriesResponse/value`` and ``MplValueType``. For further details about this endpoints parameters, please refer to the [API documentation](https://app.swaggerhub.com/apis-docs/johannes_kinzig/thingsboard-rest-api/3.7.0#/telemetry-controller/getTimeseries).

#### saveEntityTelemetry()
It is also possible to save telemetry data on behalf of a specified entity (e.g. device, refer to ``TbQueryEntityTypes``). The following listings show two examples for ``TBUserApiClient/saveEntityTelemetry(for:entityId:timeseriesData:responseHandler:)``. The completion handler is called on success.

Save timeseries data with server timestamp at time of message arrival:
```swift
let sampleTimeseriesData = ["SampleIMEI": 999999999999999, "SampleBattery": 100] as [String : Any]
myClient?.saveEntityTelemetry(for: .device, entityId: "entityId-as-UUID-string", timeseriesData: sampleTimeseriesData) {
    print("Success!")
}
```

Save timeseries data with specific timestamp (e.g. to push previously recorded data):
```swift
let sampleTimeseriesData = ["ts":1634712287000, "values": ["SampleIMEI": 999999999999999, "SampleBattery": 100]] as [String : Any]
myClient?.saveEntityTelemetry(for: .device, entityId: "entityId-as-UUID-string", timeseriesData: sampleTimeseriesData) {
    print("Success!")
}
```

#### deleteEntityTimeseries()
Timeseries data can be deleted for a specific timeframe, given the entity (``TbQueryEntityTypes``), identified based on its id, type and key names. To delete all timeseries data for a given entity and key, provide timeframe starting with 0 and ending with current datetime: `startTs: 0`, `endTs: Int64(Date().timeIntervalSince1970) * 1000`. On success, the completion handler is called.

```swift
let dateTimeNow = Int64(Date().timeIntervalSince1970) * 1000
myClient?.deleteEntityTimeseries(for: .device, entityId: "entityId-as-UUID-string", keys: ["SampleIMEI", "SampleBattery"], startTs: 0, endTs: dateTimeNow, deleteLatest: true) {
    print("Success!")
}
```
For further details regarding endpoint parameters and their functionality, refer to official [API documentation](https://app.swaggerhub.com/apis-docs/johannes_kinzig/thingsboard-rest-api/3.7.0#/telemetry-controller/deleteEntityTimeseries).

